[{"content":"近期参加了 ICT 网络技术竞赛，关于赛前培训的学习笔记在这里记录一下。\n计算机网络基础及网络模拟器的初步认识（第一节） 初级名词解释 行业现状这里不再赘述，直接进入计算机网络基本名词的解释：\n1.数字信号：由二进制比特流组成，简单来说就是一连串的0和1。\n2.LAN（局域网）：是一种在特定区域内由多台计算机设备（如服务器、工作站）通过线缆（如同轴线缆、双绞线、光缆等）连接起来实现的资源共享的计算机网络\n忽略上面这些繁琐的解释，目前我们只需要知道一切能上网的智能化终端设备（如📱、💻）都处于局域网内。常见的局域网相信会上网的人都耳熟能详，如家庭网、校园网、企业网、园区网等。\n3.MAN（城域网）：是一种覆盖城市或大型城镇区域的计算机网络，通常用于连接城市内的不同地点，如企业、学校、医院等。简单来说，城域网就是用于连接一个城市内部不同局域网的网络。\n4.WAN（广域网）；跨越地理位置的综合型网络，通常跨越不同国家甚至各大洲，使用公共网络（如互联网）或专用网络（如MPLS）连接不同的网络节点 目前世界上最大的广域网是Internet（因特网）。\n在日常生活中，我们常说的上网冲浪指的就是在一个局域网内通过链接到广域网来获取到各个城域网乃至其他局域网内部的网络资源；上网上网，上的就是广域网。因此，我们可以简单理解为 ICT（Information and Communication Technology，信息与通信技术）网络技术所研究的就是广域网的接入技术。\n图片来源：深入理解计算机网络（四）：网络层 | Taogen\u0026rsquo;s Blog\n5.网络适配器：俗称“网卡”，一种硬件设备，用于将计算机或其他设备连接到网络。终端需要基于网络适配器进行上网。网络适配器有以太网网络适配器（以太网卡）、无线网网络适配器（无线网卡）、虚拟网网络适配器（虚拟网卡）三类。\n在Windows终端中键入ipconfig（linux/unix键入ifconfig或ip）可以查看设备的网络配置信息：\n6.实现用户上网的条件\n\u0026lt;1\u0026gt; 物理条件：传递信号的介质，如网线、光纤、电话线、电磁波（无线信号）\n\u0026lt;2\u0026gt; 网络通信协议：TCP/IP（Transmission Control Protocol / Internet Protocol，传输控制协议/网际协议）协议族，详细介绍可以参考 TCP/IP介绍 | 菜鸟教程\n7.IP 地址：在网络中用于唯一标识一台网络设备。由于 IPv6（Internet Protocol Version 6）尚未普及，现在我们常说的 IP 地址通常指 IPv4（Internet Protocol Version 4）地址。通常以三点分十进制数形式表示，如 192.168.1.1 。但计算机内部只能存储二进制数据，故其原型由32位二进制数组成 。如上面提到的192.168.1.1，可通过以下方法快速转换为二进制数：\n已知存在以下关系\n1 2 3 4 5 6 7 8 0000 0001 == 1 == 2^0 0000 0010 == 2 == 2^1 0000 0100 == 4 == 2^2 0000 1000 == 8 == 2^3 0001 0000 == 16 == 2^4 0010 0000 == 32 == 2^5 0100 0000 == 64 == 2^6 1000 0000 == 128 == 2^7 第一位十进制数 192 = 128 + 64，可以快速得出其二进制形式 1100 0000 。\n以此类推：\n168 = 128 + 32 + 8 ==\u0026gt; 1010 1000 1 ==\u0026gt; 0000 0001 所以 192.168.1.1 在计算机中储存的值就是 1100 0000.1010 1000.0000 0001.0000 0001 8.IP 地址配置规则\n从上面 IP 地址的二进制形式我们可以很容易得出，其十进制形式的取值范围在0 ~ 255之间。但在配置 IP 地址时，并不是每一个数值都可以使用。\n在配置 IP 地址时，我们需要遵循以下规则：\n\u0026lt;1\u0026gt; 首位的取值范围在1~223之间\n\u0026lt;2\u0026gt; 中间两位的取值范围在0~255之间\n\u0026lt;3\u0026gt; 末尾的取值范围在1~254之间\n具体原因如下：\n首先需要知道，末尾为0的 IP 表示网络的起始地址，通常会用于标识整个网络。在 IP 地址中，网络地址和主机地址是分开的，网络地址用于标识网络，而主机地址用于标识网络中的设备。为避免混淆，IP 地址末尾不为0便成为了一种约定俗成的做法；而末尾为255的 IP 地址则用于广播（允许数据从一个源发送到网络中的所有设备），被称为广播地址，末尾不为255同样是为了避免混淆不同标识功能的 IP 地址。\n至于首位的范围，则需要引入IP 地址的分类来解释：\n在 IPv4 中，我们以首位的取值范围为标准将 IP 地址分为 A、B、C、D、E 五大类：\nA类地址：首位的范围在1~126之间\nB类地址：首位的范围在128~191之间\nC类地址：首位的范围在192~223之间\nD类地址：首位的范围在224~239之间\nE类地址：首位的范围在240~255之间\n其中，D类地址用于组播（允许数据从一个源发送到多个接收者）、E类地址用于科研，这两类地址不能私下使用 。因此，在设置 IP 地址时，首位的范围在1~223之间。\n9.IP 地址的结构\n针对 IP 地址本身，我们根据各部分标识功能的差异将其细分为网络位和主机位：\n网络位：用于标识整个网络，是一个范围。如 192.168.10.100 的网络位是 192.168.10，表示网络地址 （注意，这里所提到的“网络地址”和上面提到的“用于标识整个网络的‘网络地址（起始地址）’”并不是同一个概念） 为192.168.10.0~192.168.1.255的所以网络设备组成的通信网络。这就是上面所提到的，IP 地址末尾不为0的原因。\n主机位：网络中主机的标识，具体到一个网络中的一个用户。如上面的 IP 地址主机位为100 。\n我们可以将网络位简单理解为一个 IP 地址的“姓”，而主机位就是它的“名”。\n在不同种类的 IP 地址中，不同网络所拥有网络地址数量也不同。\n例如：\n对于A类地址 10.100.100.100 ，其网络位是 10.0.0.0 。因此，算上起始地址和广播地址，单个A类地址在网络中所拥有的地址数量就是256^3=2^24 。\n同理，对于B类地址 172.16.100.100 ，其网络位是 172.16.0.0 ，则单个B类地址在网络中拥有256^2=2^16个网络地址 ；\n单个C类地址在网络中拥有256^1=2^8个网络地址 。\n是否感觉有一些混乱？计算机也怎么觉得\n因此，为了准确标识一个 IP 地址所处的网络范围，我们引入子网掩码这个概念。\n子网掩码通常与 IP 地址成对出现，在给网络设备配置 IP 地址时，后面必须配上子网掩码，否则 IP 无效 。\n一个 IP 地址可以拥有不同的子网掩码，以标识它们处于不同的网络范围。\n对于A、B、C三类地址，它们默认的子网掩码分别是 255.0.0.0、255.255.0.0、255.255.255.0。\n那么子网掩码如何标识一个 IP 地址所处的网络范围呢？\n将一个 IP 地址和其子网掩码做与运算，我们可以得到这个 IP 地址的网络号（注意其与网络位的区分）。\n如 10.1.1.1 与 10.2.2.2，使用它们默认的子网掩码 255.0.0.0 ，分别对它们进行与运算：\n1 2 3 4 5 6 7 8 9 10 11 0000 1010.0000 0001.0000 0001.0000 0001 \u0026amp;1111 1111.0000 0000.0000 0000.0000 0000 ________________________________________ 0000 1010.0000 0000.0000 0000.0000 0000 0000 1010.0000 0010.0000 0010.0000 0010 \u0026amp;1111 1111.0000 0000.0000 0000.0000 0000 ________________________________________ 0000 1010.0000 0000.0000 0000.0000 0000 /*如果采用默认的子网掩码，在运算过程中，我们可以通过“遇到掩码255时不变；遇到掩码为0时为0”的结论来简化运算*/ 进制转换后，结果均为 10.0.0.0 ，代表二者的网络号一致。当两个 IP 地址的网络号相同时，就代表它们处于一个相同的网络范围，可以相互通信 。\n另外，在配置网络信息的过程中，我们常常会看到类似于 192.168.1.1/24、172.10.12.100/16、10.1.1.1/8 等这样 IPv4地址+/+n 的地址格式，其中/ 后的数值 n 被称为前缀长度，表示表示子网掩码的前 n 位是 1，其余位是 0 。\n10.三大基本网络设备：\n路由器（Router）：连接广域网的设备\n交换机（Switch）：连接局域网的设备，接口多，可使多台终端设备接入\n调制解调器（Modren）：数字信号转换为模拟信号（调制）以便通过电话线传输，同时将接收到的模拟信号转换回数字信号（解调）。我们耳熟能详的光猫就是调制解调器的一种，全称为光网络调制解调器（Optical Network Modem，简称ONU），用于光信号和电子信号的相互转换\n网络模拟器的初步认识及基础操作 环境及工具准备 这里我们使用 Cisco Packet Tracer（思科模拟器） 进行网络环境的模拟搭建。\n其工作区界面示例（v8.2.2）如下：\n工具的下载和汉化以及汉化后可能出现的问题这里给出以下参考链接：\n最新版下载链接（v8.2.2）\n汉化项目链接\nPacket Tracer更改字体后命令行黑屏问题解决 | zyc666\n具体过程这里不再赘述。\n路由器基础配置（基础操作认识） 首先来到网络设备一栏，选择路由器型号，这里我们使用1841型：\n放置两个待连接的路由器后，我们选择连接线路,这里选择自动选择连接类型：\n点击路由器进行连接后，在两个路由器的连接接口出会显示端口信息（需要在设置中进行设置，详情这里不赘述）。点击其中一个路由器进入其命令行界面（IOS）对其进行网络配置：\n在配置前我们需要首先了解一下设备的几个基本模式：\n1 2 3 4 hostname\u0026gt; //用户模式，用于衡量一台设备是否正常运行 hostname# //特权模式，用于通信测试（通常使用 ping 指令） hostname(config)# //全局配置模式，可进行功能性代码的配置 hostname(config-if)# //端口配置模式，可进行端口的信息及状态配置 配置命令如下:\n1 2 3 4 5 hostname\u0026gt;en //进入特权模式 hostname#configure terminal //进入全局配置模式 hostname(config)#int f0/0 //进入端口配置模式 hostname(config-if)#no shutdown //启用端口 hostname(config-if)#ip add 10.1.1.1 255.0.0.0 //配置ip和子网掩码 此外，还有一些常见命令需要掌握：\n1 2 3 4 5 hostname(config)#hostname FJUT_1 //配置主机名 hostname(config-if)#no ip address [ip-address] //删除地址 #exit //返回上一级 #end //返回全局配置模式 ? //帮助信息 命令可简写，且可使用Tab键补全。\n对另一台路由器进行类似配置，配置完成后可以发现端口颜色由红色变为了绿色（将两个端口全部启用后就会改变）。将鼠标悬停在设备上能够看到设备信息：\n配置完成后，我们键入 ping [ip-address] 指令进行通信测试，出现以下结果说明配置成功：\n这里说明一下，第一次之所以会出现丢包25%的情况，简单理解是因为路由器连接时需要先进行探路测试，这个包就是被丢出去就是用于“探路”的。\n","date":"2024-11-27T21:31:12+08:00","image":"https://krseoul.imgtbl.com/i/2024/11/27/6747235884102.jpg","permalink":"https://Benjamin101V.github.io/p/ict-%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E7%AB%9E%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"ICT 网络技术竞赛学习笔记"},{"content":"C语言自学得差不多了，可以写博客装B啦，哈哈哈哈\n介于博主有些急于求成，虽然自学进度推进得差不多了，但是基础并不扎实，所以决定将博客作为巩固自己学习成果的方法之一\n这篇讲数组。数组作为C语言的重难点和指针并称为“C语言的两大高墙”（好吧其实是我瞎说的，其实没有想象中的那么难 欸嘿~），总之想要学好C语言，深入探究数组及其应用还有它和指针的联系是必不可少的。\nC 数组基础 数组的概念 数组，顾名思义，就是一组相同类型的变量，用于储存一系列相同类型的数据。\n数组的声明并不是声明一个个单独的变量，而是声明一个数组变量，用于代表一组相同类型的变量。\n所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。\n（图片来源：C 数组|菜鸟教程）\n在使用数组时，我们通过 []（下标访问操作符） 对数组进行访问 ，[] 中填写的便是数组的下标（或引索值）。需要特别注意的是，在C语言中，数组的下标从0开始，即任意数组的第一个元素下标为0（如上图）。\n声明数组 与普通变量相同，在使用数组前，我们需要对其进行声明，声明方法与普通变量类似。\n1 type arrayName[arraySize]; 其中，type 是数组的数据类型，arrayName 是数组名（记住这个东西，后面会考），arraySize 是数组的大小，即数组 arrayName 具有的元素个数，并不是数组最后一个元素的下标。\n例如：\n1 2 int arr1[10]; double arr2[5]; 这段代码声明了一个 int 类型和一个 double 类型的数组，它们分别含有10个和5个元素。\n初始化数组 在对数组进行声明后，我们需要对其进行初始化。初始化的方法一般有以下3种：\n1 int arr[5]={101,102,103,104,105}; 在上面的代码中，数组 arr 的大小确定，并直接对数组 arr 的每个元素进行赋值。\n1 2 int arr[5]={0}; int arr[5]={}; 在这段代码中，数组 arr 的大小确定，并将数组中的每个元素初始化为0。\n1 int arr[]={101,102,103,104,105}; 在这段代码中，数组 arr 的大小由初始化时元素的个数确定，并从 arr[0] 开始依次对数组元素进行赋值。\n同时，也可以单独对一个数组元素进行初始化：\n1 int arr[1]=102; 上面这段代码将数组 arr 中下标为“1” 的元素，即数组的第二个元素赋值为102。\n访问数组元素 上面提到，在访问数组元素时，我们通过 []操作符对其进行访问。事实上，在日常使用中，我们一般通过 数组名+[元素下标] 的格式访问数组元素：\n1 int n=arr[1]; 上面的代码将数组 arr 的第2个元素的值赋给变量 n\n在日常使用中，我们常常通过循环遍历的方式对一个数组的元素进行访问：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[5];//声明一个具有5个 int 类型元素的数组 /*通过遍历获取数组元素值*/ for(int i=0;i\u0026lt;5;i++){ arr[i]=101+i; //scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i]); /*动态输入*/ } /*通过遍历输出数组元素值*/ for(int i=0;i\u0026lt;5;i++){ printf(\u0026#34;arr[%d]=%d\\n\u0026#34;,i,arr[i]); } return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 5 arr[0]=101 arr[1]=102 arr[2]=103 arr[3]=104 arr[4]=105 获取数组长度 在使用数组的过程中，我们常常需要调用它的长度。在C语言中，我们通过 sizeof 运算符获取数组长度。\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[]={101,102,103,104,105}; int length=sizeof(arr)/sizeof(arr[0]); printf(\u0026#34;Length of arr=%d\\n\u0026#34;,length); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 Length of arr=5 在上面的代码中，单个 sizeof 运算符计算对应变量在内存中的大小。sizeof(arr) 计算整个数组所占用的内存大小，sizeof(arr[0]) 计算数组中单个元素所占用的内存大小，二者相除就是数组的元素个数，即数组的长度。\n在开发过程中，我们也可以通过宏定义的形式将这段代码提至预处理阶段：\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; #define LENGTH(array) sizeof(array)/sizeof(array[0]) int main() { int arr[]={101,102,103,104,105}; int length=LENGTH(arr); printf(\u0026#34;Length of arr=%d\u0026#34;,length); return 0; } 当上面这段代码被编译并执行后，结果与上面无异。\n数组名 还记得这个东西吗？都说了会考的吧\n在 C 语言中，数组名表示数组的地址，即数组首元素的地址。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。\n这就意味着，数组名可以直接当作指针使用。不过需要注意的是，由于在声明后，数组的内存地址是确定的，所以数组名是一个常量指针，这意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[5]; int *ptr1=arr; int *ptr2=\u0026amp;arr[0]; printf(\u0026#34;%#p %#p\\n\u0026#34;,arr,\u0026amp;arr[0]); printf(\u0026#34;%#p %#p\\n\u0026#34;,ptr1,ptr2); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 0X000000000061FDF0 0X000000000061FDF0 0X000000000061FDF0 0X000000000061FDF0 在上面这段代码中，我们使用了两种方法获取数组的内存地址。可以看出，arr 作为数组名可以直接作为指针使用。\n不过需要注意的是，虽然数组名表示数组的地址，但在大多数情况下，数组名会自动转换为指向数组首元素的指针。这意味着我们可以直接将数组名用于指针运算，这在后面我们会再详细讨论。下面是一个函数传递的参数为数组的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; void printArray(int arr[],int size) { for(int i=0;i\u0026lt;size;i++){ printf(\u0026#34;%d \u0026#34;,arr[i]); // 数组名arr被当作指针使用 } } int main() { int myArray[5]={10, 20, 30, 40, 50}; printArray(myArray, 5); // 将数组名传递给函数 return 0; } 在上述代码中，printArray 函数接受一个整数数组和数组大小作为参数，我们将 myArray 数组名传递给函数，函数内部可以像使用指针一样使用 arr 数组名。\n多维数组 上面所讨论的内容主要围绕一维数组展开。现在我们将多个一维数组对齐排列，这样就得到了一个二维数组。类似的，将多个二维数组对齐排列，我们就得到了一个三维数组，以此类推。\n与一维数组相似，一个N维数组的声明通常以如下形式展开：\n1 type arrayName[size1][size2]...[sizeN]; 下面是一个 double 类型三维数组声明的实例：\n1 double arr[5][4][3]; 在多维数组中，二维数组的使用最为常见，下面对其的使用进行较为详细的分析。\n二维数组的概念 二维数组是最简单的多维数组。在上面我们说到，一个 N维数组 由若干个 (N-1)维数组 排列而成，由此可得出二维数组的本质：二维数组的本质是一维数组的排列，因此二维数组几乎继承了一维数组的所有性质。\n声明二维数组 前面铺垫了这么多，这里直接上实例：\n1 int a[3][4]; 上面的实例声明了一个3行4列的整型二维数组。其结构可以通过下图简单理解：\n图片来源：C多维数组 | 菜鸟教程\n初始化二维数组 二维数组的初始化有多种方式。\n1 2 3 4 5 int arr[3][4]={ {1,2,3,4}, //arr[0][n] {2,3,4,5}, //arr[1][n] {3,4,5,6} //arr[2][n] }; 上面的实例逐行初始化了一个3行4列的整型二维数组，在熟知一维数组初始化过程和二维数组本质的前提下，我们可以更好的理解这一过程。\n当然，我们也可以将初始化的内容放在同一行：\n1 int arr[3][4]={{1,2,3,4},{2,3,4,5},{3,4,5,6}}; 这样操作的效果与上面无异。\n同时，初始化内容中嵌套的括号可以省略，就像下面这样：\n1 2 3 4 5 6 7 int arr[3][4]={ 1,2,3,4, 2,3,4,5, 3,4,5,6 }; int arr[3][4]={1,2,3,4,2,3,4,5,3,4,5,6}; 访问二维数组 与一维数组相同，在访问二维数组的数组元素时，我们也通过使用元素下标（或引索值）访问数组元素。\n例如：\n1 int n=arr[2][3]; 在上面的代码中，我们获取数组 arr 中第3行第4列的元素值，并将其赋给整型变量 n\n在日常使用中，我们常常通过循环嵌套的方式对一个多维数组的元素进行遍历访问：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[3][4]; //声明一个3行4列的整型二维数组 /*遍历输入*/ int temp=101; for(int i=0;i\u0026lt;3;i++){ //行数 for(int j=0;j\u0026lt;4;j++){ //列数 arr[i][j]=temp+j; //scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i][j]); /*动态输入*/ } temp++; } /*遍历输出*/ for(int i=0;i\u0026lt;3;i++){ for(int j=0;j\u0026lt;4;j++){ printf(\u0026#34;arr[%d][%d]=%d\\t\u0026#34;,i,j,arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 arr[0][0]=101 arr[0][1]=102 arr[0][2]=103 arr[0][3]=104 arr[1][0]=102 arr[1][1]=103 arr[1][2]=104 arr[1][3]=105 arr[2][0]=103 arr[2][1]=104 arr[2][2]=105 arr[2][3]=106 在上面的实例中，我们声明了一个3行4列的整型二维数组，并创建了一个中间值，使其在通过循环遍历初始化时能够使每一行的第一个元素值较上一行+1。每一行均为一组自然数列。\n字符数组 C 字符串 字符串大小 在C语言中，字符串的应用也十分广泛。\n本质上，字符串实际上是使用空字符 \\0 结尾的一维字符数组。\n空字符又称结束符，缩写 NUL，是一个数值为 0 的控制字符，\\0 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。\n对于一个字符串而言，由于其末尾存在一个空字符 \\0，故其大小要比它的字符数多一个。下面的实例能够证明这一点：\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main() { char string[]=\u0026#34;VIRTUALGUARD\u0026#34;; printf(\u0026#34;Length of string:%d\\n\u0026#34;,sizeof(string)/sizeof(string[0])); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 Length of string:13 可以看出，字符串string本身只有12个字符，但输出的结果却显示它的大小为13。\n字符数组的初始化 在C语言中，字符数组的初始化通常有以下两种方式：\n1 2 3 char string[]={\u0026#39;V\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;L,\u0026#39;\\0\u0026#39;}; /*可根据实际情况决定是否指定数组大小，若有指定大小则需要考虑溢出*/ char string[]=\u0026#34;VIRTUAL\u0026#34; 在实际应用中，后者的使用居多。\n需要注意的是，在使用后者的方式进行初始化时，编译器会自动在字符串的末尾加上\\0，这一点在上一个实例可以看出；而前者则没有这个过程，因此在使用前者的方式进行初始化时，数组的末尾必须包含\\0，用以标示字符串的结束。否则，程序在执行时可能会出现意想不到的的结果。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int main() { char string[]=\u0026#34;VIRTUALGUARD\u0026#34;; char str[]={\u0026#39;B\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;N\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;N\u0026#39;}; printf(\u0026#34;Length of string:%d\\n\u0026#34;,sizeof(string)/sizeof(string[0])); printf(\u0026#34;Length of string:%d\\n\u0026#34;,sizeof(str)/sizeof(str[0])); printf(\u0026#34;%s\\n\u0026#34;,string); printf(\u0026#34;%s\\n\u0026#34;,str); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 Length of string:13 Length of string:8 VIRTUALGUARD BENJAMINVIRTUALGUARD 可以看出，字符数组str的大小只有8个字节，和其字符数相等。这里在对str进行输出时，在将str包含的所以字符全部输出后，printf函数还将string的内容一同打印了出来：\n这是因为在内存中，栈区数据对应的地址是从从高到低排列的，举例说明：比如现在有一个变量a，又有一个变量b，b比a后创建，那么就说b的地址比a的高。注意，上面说到的地址的高低是相对而言的，不是绝对的。\n在上面的实例中，字符数组str的地址相比起string的地址就是高地址，在执行打印str的代码时，printf函数在遍历完str的所有字符后，未检测到\\0的存在，故继续执行打印程序，来到地址更低的存放string数据的内存空间，并将其中的内容一并打印到窗口上，直到读取到string末尾的\\0字符，打印程序终止。因此我们看到的输出结果就是字符串str和string组合起来的结果。\n上面这部分解说用到的概念涉及汇编的内容，详情可参考汇编相关的资料。\n字符串函数 针对字符串进行操作的函数在C语言的应用也十分广泛，C标准库中定义了大量操作字符串的函数，定义于string.h中，详情可参考 C 标准库 - \u0026lt;string.h\u0026gt; | 菜鸟教程\n下面的实例中所列举的字符串操作函数相对常见。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char str[8]={\u0026#39;V\u0026#39;,\u0026#39;I\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;T\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;L\u0026#39;,\u0026#39;\\0\u0026#39;}; char string1[]=\u0026#34;VIRTUAL\u0026#34;; printf(\u0026#34;%s\\n%s\\n\u0026#34;,str,string1); char string2[]=\u0026#34;GUARD\u0026#34;; char string3[8]; //string1=str strcpy(string3,string1);\t//复制粘贴 string1-\u0026gt;string3 printf(\u0026#34;strcpy(string3,\u0026#39;VIRTUAL\u0026#39;)-\u0026gt;%s\\n\u0026#34;,string3); strcat(string3,string2);\t//连接 string3-string2 printf(\u0026#34;strcat(\u0026#39;VIRTUAL\u0026#39;,\u0026#39;GUARD\u0026#39;)-\u0026gt;%s\\n\u0026#34;,string3); int len=strlen(string3);\t//计算连接后string3的总长度 printf(\u0026#34;length of string3:%d\\n\u0026#34;,len); char passwd[]=\u0026#34;VIRTUAL\u0026#34;; char input1[25]=\u0026#34;VIRTUAL\u0026#34;; //scanf(\u0026#34;%s\u0026#34;,input1); if(strcmp(input1,passwd)==0){//比较字符串,相同返回0 printf(\u0026#34;Pass!\\n\u0026#34;); } else{ int ret=strcmp(input1,passwd); printf(\u0026#34;Error!\\n\u0026#34;); printf(\u0026#34;return %d\u0026#34;,ret);//不同，如果 input\u0026lt;passwd 则返回小于0；如果 input\u0026gt;passwd 则返回大于0 } char string4[]=\u0026#34;VIRTUALGUARD{}\u0026#34;; char input2=\u0026#39;{\u0026#39;; //scanf(\u0026#34;%c\u0026#34;,input2); char *ptr1=strchr(string4,input2);//返回字符串string4中第一次出现字符input2的地址 if(ptr1!=NULL){ printf(\u0026#34;First occurrence of \u0026#39;%c\u0026#39; found at position: %#p\\n\u0026#34;,input2,ptr1-str); } else{ printf(\u0026#34;Character not found\\n\u0026#34;); } char string5[]=\u0026#34;VIRTUALGUARD{}\u0026#34;; char in[]=\u0026#34;GUARD\u0026#34;; char *ptr2=strstr(string5,in); if(ptr2!=NULL){ printf(\u0026#34;First occurrence of \u0026#39;%s\u0026#39; found at position: %#p\\n\u0026#34;,in,ptr2-str); } else{ printf(\u0026#34;String not found\\n\u0026#34;); } char src[]=\u0026#34;VIRTUALGUARD{}\u0026#34;; char dest[25]; memcpy(dest,src,strlen(src)+1); //从src复制strlen(src)+1个字符到dest中（相当于函数void *memmove(void *dest,void *src size_t,strlen(scr)+1)） printf(\u0026#34;Copied memory: %s\\n\u0026#34;, dest); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 5 6 7 8 9 VIRTUAL VIRTUAL strcpy(string3,\u0026#39;VIRTUAL\u0026#39;)-\u0026gt;VIRTUAL strcat(\u0026#39;VIRTUAL\u0026#39;,\u0026#39;GUARD\u0026#39;)-\u0026gt;VIRTUALGUARD length of string3:12 Pass! First occurrence of \u0026#39;{\u0026#39; found at position: 0XFFFFFFFFFFFFFFC5 First occurrence of \u0026#39;GUARD\u0026#39; found at position: 0XFFFFFFFFFFFFFFB1 Copied memory: VIRTUALGUARD{} 除了上面所说的定义于string.h的字符函数，还有两个定义于stdio.h的专门用于字符串标准化输入和输出的函数：\n1 char *gets(char *str) 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。\n1 int puts(const char *str) 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。\n具体用法可参考下面的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { char str[50]; printf(\u0026#34;输入一个字符串，大小不得超过15个字符：\u0026#34;); gets(str); printf(\u0026#34;str:\u0026#34;); puts(str); return 0; } 1 2 输入一个字符串，大小不得超过15个字符：VIRTUALGUARD str:VIRTUALGUARD 函数与数组 向函数传递数组作为参数 在学习了函数后我们知道，在使用函数时，我们可以通过向函数传递参数来实现函数中所的定义的各种功能。在使用函数数时，我们能否将数组也作为函数参数的一部分传递给函数呢？答案是肯定的。\n在C语言中，我们通常采用一下三种方式来定义数组的形式参数：\n已知数组大小\n1 2 3 4 5 6 void func(int n,int arr[5],...) { /*function*/ } 未知数组大小\n1 2 3 4 5 6 void func(int n,int arr[],...) { /*function*/ } 指针作为形式参数\n1 2 3 4 5 6 void func(int n,int *parr,...) { /*function*/ } 在前面讲解一维数组时我们提到了一个转递数组给函数的实例，在那个实例中我们应该注意到向函数传递数组作为参数时，数组的实际参数是一个指针。这里需要强调一下，在向函数传递数组作为参数时，数组的实际参数是必须一个指针。\n下面我们通过一个冒泡排序的实例来进一步体会将数组作为参数传递给函数的过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; void swap(int *a,int *b) { *a=*a ^ *b; *b=*a ^ *b; //异或运算交换两数的值 *a=*a ^ *b; } void bubble_sort(int arr[],int len) { /*冒泡排序*/ for(int i=0;i\u0026lt;len-1;i++){ for(int j=0;j\u0026lt;len-1;j++){ if(arr[j]\u0026gt;arr[j+1]){ swap(\u0026amp;arr[j],\u0026amp;arr[j+1]); } } } } int main() { int arr[10]={101,104,31,354,6,78,12,65,99,343}; int length=sizeof(arr)/sizeof(arr[0]); //计算数组大小 /*调用冒泡排序函数*/ bubble_sort(arr,length); //bubble_sort(\u0026amp;arr[0],length); /*对数组第一个元素取地址，等效于直接传递数组名*/ /*打印数组元素*/ for(int i=0;i\u0026lt;length;i++){ printf(\u0026#34;arr[%d]=%d\\n\u0026#34;,i,arr[i]); } return 0; } 这里先对冒泡排序做个简单的介绍，冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。这个过程就如同烧开水时壶底的气泡往上冒，因此被称为冒泡排序。\n在上面的实例中，调用冒泡排序函数时我们采取了两种方式对数组 arr 进行了传递，分别是直接使用数组名进行传递和对数组 arr 的第一个元素取地址后再传递。由于数组在声明后在内存中的位置确定，且数组名作为指针时，其值就是数组第一个元素的地址，或者说其就是指向数组第一个元素的指针，故这两种方式可以说是完全相同的。\n需要特别注意的是，在向函数传递数组作为参数时，只能通过以上两种方式进行传递，对数组中的其他元素取地址也不行，否则编译器会报错。\n从函数返回数组 返回值：在想我的事？\n根据函数的特性，介绍完参数传递，自然也要介绍一下返回值的那些事。\nC 语言不允许返回一个完整的数组作为函数的参数。但是，由于数组名具有可作为指针传递的特性，我们可以通过指定数组名来返回一个指向数组的指针。\n如果想要从函数返回一个一维数组，我们必须声明一个返回指针的函数：\n1 2 3 4 5 6 int *func(int n,...) { /*function*/ } 另外需要注意的是，由于我们想要函数返回的数组定义于函数的内部，属局部变量，而C语言不支持在函数外返回局部变量的地址，因此，我们需要使用 static 关键字对我们想要函数返回的数组进行修饰，使其成为静态变量。\n介绍到这边，差不多可以上实例了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;time.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int *getRandom() { static int r[5]; srand((unsigned int)time(NULL)); //设置种子 for(int i=0;i\u0026lt;5;i++){ r[i]=rand()%100; //获取1~100的随机数 printf(\u0026#34;r[%d]=%d\\n\u0026#34;,i,r[i]); //直接打印 } printf(\u0026#34;\\n\u0026#34;); return r; } int main() { int *ptr=getRandom(); //获取指向返回数组的指针 for(int i=0;i\u0026lt;5;i++){ printf(\u0026#34;r[%d]=*(p+i)=%d\\n\u0026#34;,i,i,*(p+i)); //调用返回值打印 } return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 5 6 7 8 9 10 11 r[0]=4 r[1]=20 r[2]=61 r[3]=1 r[4]=97 r[0]=*(p+0)=4 r[1]=*(p+1)=20 r[2]=*(p+2)=61 r[3]=*(p+3)=1 r[4]=*(p+4)=97 从执行的结果的上半部分可以看出，由于我们在定义函数时已经在函数内部指定了打印的功能，因此在调用指针函数 getRandom() 时，无论是否调用它的返回值，在执行时都会先对获取到的随机数进行打印输出；\n而下半部分则是在主调函数中通过先获取指针函数 getRandom() 的返回值，即指向返回数组的指针，然后对其进行一系列操作后获得输出打印，其中涉及了指针运算和解引用操作。如果对指针已经有了一定的了解，这其实不难理解，在下一节我们会深入讨论指针与数组的关系及其应用。\n指针与数组 指向一维数组的指针 其实关于这部分的内容，我们在前面已经铺垫了相当之久了。在这里，我们将这部分的相关内容系统性地整理一下。\n在介绍 数组名 时我们提到，在我们声明了一个任意类型的数组后，其在内存中的位置就是确定的，不能被改变，即数组名在作为指针使用时是一个常量指针。一旦确定，它就不能再指向其他地方。\n在介绍向 函数传递数组作为参数 时我们提到，一个数组在内存中的位置用其第一个元素的地址或数组名表示，即在日常开发中，\u0026amp;arrayName[0] 等效于 arrayName ，均表示指向数组 arrayName 的指针，习惯上我们称数组名 arrayName 作为指针使用时就是指向 arrayName[0] 的指针。两种理解方式都有道理，前者在理解上将一个数组看作一个整体，后者则将数组中的元素拆分开来。在解释下文访问数组元素的另一种方法时，后者的理解更加便于表述；但在下一节讲解二维数组与指针的关系时，前者的整体思想就更加便于理解。\n另外，在介绍 从函数返回数组 时，我们提到了访问数组元素的另外一种方法。综合数组的以上特性和指针的可操作性（这里指运算和解引用），下面我们较为详细地解释这种方法的原理。\n首先看一个简单的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;stdio.h\u0026gt; int main() { double arr[5]={15.0,25.5,45.3,33.7,12.4}; double *ptr=arr; for(int i=0;i\u0026lt;5;i++){ /*使用[]操作符*/ printf(\u0026#34;arr[%d]=%lf\\t\u0026#34;,i,arr[i]); /*使用数组名作为指针*/ printf(\u0026#34;*(arr+%d)=%lf\\t\u0026#34;,i,*(arr+i)); /*使用赋值后的指针变量作为指针*/ printf(\u0026#34;*(ptr+%d)=%lf\\n\u0026#34;,i,*(ptr+i)); } return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 5 arr[0]=15.000000 *(arr+0)=15.000000 *(ptr+0)=15.000000 arr[1]=25.500000 *(arr+1)=25.500000 *(ptr+1)=25.500000 arr[2]=45.300000 *(arr+2)=45.300000 *(ptr+2)=45.300000 arr[3]=33.700000 *(arr+3)=33.700000 *(ptr+3)=33.700000 arr[4]=12.400000 *(arr+4)=12.400000 *(ptr+4)=12.400000 显然，三种访问方式所产生的效果一致。数组名 arr 作为指向 arr[0] 的指针，在对其使用 * 操作符进行解引用操作后得到的自然是 arr[0]，即数组 arr 第一个元素的值。又由于指针可以进行加法运算，且数组元素在内存中的排列是连续的，因此在对 arr 进行加法运算后再对其进行解引用，得出的便是数组 arr 中对应元素的值。而指针变量 ptr 的值是从 arr 获取（赋值）的，与上述解释同理，这里不再赘述。\n指向多维数组的指针 介绍完一维数组与指针的关系，这里我们再简单介绍一下多维数组与指针的关系。这里还是以二维数组为例展开说明。\n在介绍二维数组时我们提到，二维数组的本质是一维数组的排列。那么，结合一维数组与指针的关系，我们应该思考，在一个声明一个二维数组后，它的数组名在作为指针使用时，是否也指向整个二维数组的第一个元素呢？答案是否定的，至于为什么，我们通过下面的讲解来回答。\n对于二维数组指针的解引用访问，我们需要在一维数组的基础上辅以实例说明。\n在说明前，我们需要先注意，二维数组在内存中的储存方式与一维数组相同，是连续的。结合二维数组的本质，我们可以将其理解为多个一维数组并排存放，即所以的数组元素均存放于“同一行”。\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[3][4]; printf(\u0026#34;arr:%#p\\n\u0026#34;,arr); printf(\u0026#34;arr+1:%#p\\n\u0026#34;,arr+1); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 arr:0X000000000061FDB0 arr+1:0X000000000061FDC0 将两个地址相减，可以得出两个地址相差16字节，而我们在声明二维数组 arr 时，每一行恰好只声明了4个整型元素，结合二维数组在内存中的存放方式，由此可以推测出二维数组的一个访问规则：\n对于二维数组 array 而言，*(array+n) \u0026lt;=\u0026gt; array[n] \u0026lt;=\u0026gt; \u0026amp;array[n][0]\n通过下面的实例我们可以证明上面的推测：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;stdio.h\u0026gt; int main() { int n=1; int arr[3][4]={ 1,2,3,4, 2,3,4,5, //直观初始化 3,4,5,6 }; //scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;\u0026amp;arr[%d][0]=%#p\\t\u0026#34;,n,\u0026amp;arr[n][0]); printf(\u0026#34;arr[%d]=%#p\\t\u0026#34;,n,arr[n]); printf(\u0026#34;*(arr+%d)=%#p\\n\u0026#34;,n,*(arr+1)); printf(\u0026#34;**(arr+%d):%d\\n\u0026#34;,n,**(arr+n)); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 \u0026amp;arr[1][0]:0X000000000061FD90 arr[1]:0X000000000061FD90 *(arr+1):0X000000000061FD90 **(arr+1)=2 执行结果中上面的三行在上面已经解释过了，有意思的是第四行，这里连续用到了两次解引用操作符，而它解引用后的结果恰好就对应二维数组 arr 第二行的第一个元素。到了这里我们也就差不多能够解释前面二维数组的数组名为什么不是指向整个二维数组第一个元素的指针了。\n在解释前，我们需要引入一个概念：二级指针。顾名思义，二级指针是指向指针的指针。\n在上面的实例中，前面三行所展示的地址，是指向二维数组第二行第一列元素的指针，而事实上，它们已经被解引用（或取地址）一次了。对比三、四两行，就可以说明，arr+1 本身其实是一个二级指针，指向指向二维数组 arr 的第一行第一列元素的指针，有点绕对吧，压缩一下就变成了：指向指针，这下看明白了吧。\n换一种理解方式，结合二维数组的本质，使用我们在讲解一维数组与指针的关系时所提到的整体思想，我们也可以将 *(arr+1) 看作指向第二行整行的指针，然后再对其进行解引用，就得到了第二行的第一个元素，这样的理解方式在后面我们讲解二维数组中其他元素的访问时可能更容易被接受并理解。\n由此我们就可以完美地解释前面地问题，二维数组的数组名是指向 指向这个二维数组第一行第一列元素的指针 的指针，或者说，二维数组的数组名是指向这个二维数组第一行第一列元素的二级指针。拓展到多维数组，一个N维数组的数组名是指向这个N维数组第一个元素的N级指针。\n那在我们需要访问其他元素时又应该如何操作呢？其实很简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[3][4]={ 1,2,3,4, 2,3,4,5, 3,4,5,6 }; int i=1,j=3; printf(\u0026#34;arr[%d][%d]=%d\\n\u0026#34;,i,j,arr[i][j]); printf(\u0026#34;*(*(arr+%d)+%d)=%d\\n\u0026#34;,i,j,*(*(arr+i)+j)); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 arr[1][3]=5 *(*(arr+1)+3)=5 在上面的实例中，我们访问了第二行第四列的元素。\n在上面的讲解中我们提到，我们可以将 *(arr+1) 看作指向第二行的指针，再根据二维数组的本质，我们就可以把 *(P+3)（P == *(arr+1)，这里把它看作是一个整体，便于理解）看作是一个一维数组的解引用。这样的理解方式既能将其和一维数组的指针联系起来，又便于理解和记忆，可谓一举多得。\n通过下面的示意图我们可以更加深刻理解上面的解说：\n图片来源：指针和二维数组 | 田安Anne的博客\n将上面结论拓展到其他多维数组：\n1 2 3 4 5 *(arr+i) == arr[i] *(*(arr+i)+j) == arr[i][j] *(*(*(arr+i)+j)+k) == arr[i][j][k] .......... /*以此类推*/ 可以看出其本质就是一个嵌套解引用的过程\n参考资料：\nC多维数组 | 菜鸟教程\nC字符串 | 菜鸟教程\n指针和二维数组 | 田安Anne的博客\nEND ","date":"2024-11-02T21:39:30+08:00","image":"https://krseoul.imgtbl.com/i/2024/11/30/6749f6d551976.png","permalink":"https://Benjamin101V.github.io/p/c-%E6%95%B0%E7%BB%84/","title":"C 数组"},{"content":"最近完成了 C 指针的初步学习，通过这篇博客记录一下\n作为C中一个十分重要的概念，指针在C中的应用实例可谓俯拾皆是。\n通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。\nC 指针初阶 一个 C 指针实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;stdio.h\u0026gt; int main() { int var_virtual=101; int *ptr=\u0026amp;var_virtual; //定义指针变量 printf(\u0026#34;var_virtual的变量地址：%p\\n\u0026#34;,ptr); printf(\u0026#34;var_virtual的变量地址：%#p\\n\u0026#34;,ptr); /* printf可以使用使用格式控制串“%o”、“%X”分别输出八进制整数和十六进制整数，并使用修饰符“#”控制前导显示*/ return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 var_virtual的变量地址：000000000061FE14 var_virtual的变量地址：0X000000000061FE14 通过上面的实例，我们可以得到以下两点结论；\n1\u0026gt;变量 ptr 是一个指针变量，在上述实例中用于储存变量 var_virtual 的地址。\n2\u0026gt;每一个变量都有一个内存位置，每一个内存位置都定义了可使用 \u0026amp; 运算符访问的地址，它表示 了在内存中的一个地址。\n在了解了内存地址的简单概念以及如何访问它后，我们便可以开始了解指针的概念了。\n指针的概念 在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向 （points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。\n简单来说，指针其实就是内存地址，指针变量就是用于存放内存地址的变量。因此指针常用于内存地址的传递和变量的访问。\n与其他变量相同，在使用指针变量前需要对其进行声明，声明方法如下：\n1 type *var_name; 其中 type 是变量类型，var_name 是变量名，* 是一个操作符，我们称它为解引用操作符，在后面的内容中我们还会再提到它。\n下面是一些指针变量的有效声明案例：\n1 2 3 4 int *ip; //整型指针 float *fp; //浮点型指针 double *dp; //双精度浮点型指针 char *ch; //字符指针 实际数据类型丰富多样，但是它们的所对应的指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制无符号整数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n那么区分不同类型的指针变量的意义是什么呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int n=5; int *ip=\u0026amp;n; char *ch=(char*)\u0026amp;n; printf(\u0026#34;%#p\\n\u0026#34;,\u0026amp;n); printf(\u0026#34;%#p\\n\u0026#34;,ip); printf(\u0026#34;%#p\\n\u0026#34;,ip+1); printf(\u0026#34;%#p\\n\u0026#34;,ch); printf(\u0026#34;%#p\\n\u0026#34;,ch+1); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 4 5 0X000000000061FE0C 0X000000000061FE0C 0X000000000061FE10 0X000000000061FE0C 0X000000000061FE0D 从上面这个实例可以看出，给 int 类型和 char 类型指针变量的值分别加一后，int 类型的内存地址的值被加上了四，而 char 类型的地址值只加上了一。\n简单来说，指针的类型决定了指针向前或者向后走一步有多大（距离）。\n同时，我们还可以由此引申出一个新的结论： 指针的类型决定了对指针解引用的时候有多大的权限（能操作几个字节）。 比如：char* 的指针解引用就只能访问一个字节，而int* 的指针的解引用就能访问四个字节。这个结论可以通过在对下面这段代码进行调试时进行内存监视得到证明。\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { int var=5; int *ip=\u0026amp;var; char *ch=(char*)\u0026amp;var; *ip=0; *ch=0; return 0; } 在调试过程中，注意在对 ip 和 ch 这两个指针变量进行解引用操作时观察内存监视窗口的变化\n需要额外注意的是，在不同的编程语言和平台上，指针的大小可能会有所不同，但通常在32位系统上是4字节，在64位系统上是8字节。\n指针的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int var=5; //声明实际变量 int *ptr=\u0026amp;var; //声明指针变量并使用var的地址初始化 printf(\u0026#34;var的地址：%#p\\n\u0026#34;,\u0026amp;var); /*使用\u0026amp;操作符返回变量的地址*/ printf(\u0026#34;ptr储存的地址：%#p\\n\u0026#34;,ptr); /*打印指针变量储存的地址*/ printf(\u0026#34;*ptr指向的值：%d\\n\u0026#34;,*ptr); /*使用指针访问变量的值*/ return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 2 3 var的地址：0X000000000061FE14 ptr储存的地址：0X000000000061FE14 *ptr指向的值：5 上面的实例涉及了以下这些操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。在使用指针时我们会频繁进行这些操作。\nNULL （空指针） NULL 指针是一个定义在标准库中的值为零的常量。\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int *ptr=NULL; printf(\u0026#34;NULL 的地址：%#p\u0026#34;,ptr); //printf(\u0026#34;%d\\n\u0026#34;,*ptr); return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 NULL 的地址：0000000000000000 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置，因此，上面代码中注释掉的部分是错误的，取消注释后编译会报错 “Segmentation fault（段错误）” 。按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。\n介于 NULL 的特殊性，我们会经常用到以下代码用于检测一个指针是否为 NULL ：\n1 2 3 4 5 6 7 if(ptr){ /*expression*/ //ptr不为 NULL ，进入语句 } if(!ptr){ /*expression*/ //ptr为 NULL ，进入语句 } 野指针 顾名思义，是一个野生的指针 是指向位置不确定的指针变量，其值是内存中的随机地址，指向内存中的随机值，所以野指针具有不确定性————对其解引用就是访问一个不确定的地址，所以其结果是不可知的，可以是内存中的任何值。\n野指针通常由以下三种情况产生：\n1\u0026gt;未初始化指针变量\n1 int *ptr; //ptr未初始化，默认为随机值 2\u0026gt;指针越界访问\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { int arr[5]={0}; int *ptr=arr; for(int i=0;i\u0026lt;=5;i++){ printf(\u0026#34;%d \u0026#34;,*(ptr++)); /*解引用过程中指针指向的范围超出数组arr的初始化范围*/ } return 0; } 当上面这段代码被编译并执行后，会产生以下结果：\n1 0 0 0 0 0 5 其中第六个元素“5”是内存中的随机值，是越界访问的结果。\n3\u0026gt; 指针指向的空间释放后未被设置成空指针\n这属于动态内存模块的内容，详情后续会提到\n由于其不确定性，野指针在程序中通常会引发一些意想不到的结果，甚至导致程序崩溃。因此，养成良好的编程习惯，规避野指针的产生就显得尤为重要。\n以下是一些规避野指针的方法：\n1.在声明指针变量时立即初始化它，或者将其初始化为NULL\n2.避免指针的越界访问\n3.在释放动态分配的内存后，将指针变量设置为NULL\n4.在使用指针变量之前，确保它指向一个有效的内存地址，即检查指针的有效性\n参考资料：C 指针 | 菜鸟教程\nEND ","date":"2024-10-08T16:43:48+08:00","image":"https://krseoul.imgtbl.com/i/2024/11/28/674890c762340.jpg","permalink":"https://Benjamin101V.github.io/p/c-%E6%8C%87%E9%92%88/","title":"C 指针"},{"content":"\n动图来源：Hello Apple by Meritt Thomas\n","date":"2024-10-07T23:01:24+08:00","permalink":"https://Benjamin101V.github.io/p/hello/","title":"Hello"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Benjamin101V.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://Benjamin101V.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://Benjamin101V.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://Benjamin101V.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://Benjamin101V.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://Benjamin101V.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://Benjamin101V.github.io/p/emoji-support/","title":"Emoji Support"}]